# -*- coding: utf-8 -*-
"""LOAN_PREDICTION.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LzGSEAhq7k3IeXiOs1Qh-qSldgMWQZ75

#INTRODUCTION

This project helps apply for loans and eceive notifications upon approval. With the data provided by the applicant the system tells the user about the availability of the loan
"""

import numpy as np
import pandas as pd
import  matplotlib.pyplot as plt
import seaborn as sns
from sklearn import svm

df= pd.read_csv("LOAN.csv")

df.info()

print(df.head())

df.isnull().sum()

df['LoanAmount_log']= np.log(df['LoanAmount'])
df['LoanAmount_log'].hist(bins=20)

import seaborn as sns
import matplotlib.pyplot as plt

# Group the data by 'LoanAmount' and count the number of occurrences
loan_amount_counts = df['LoanAmount'].value_counts().reset_index()
loan_amount_counts.columns = ['LoanAmount', 'Count']

# Sort the data by 'LoanAmount' for a more meaningful plot
loan_amount_counts = loan_amount_counts.sort_values(by='LoanAmount')

# Create a countplot
plt.figure(figsize=(12, 6))  # Adjust the figure size for better visibility
sns.barplot(x='LoanAmount', y='Count', data=loan_amount_counts, palette='Set1')
plt.xticks(rotation=90)  # Rotate x-axis labels for better readability

plt.title("Number of People Who Took Loans Grouped by Loan Amount")
plt.xlabel("Loan Amount")
plt.ylabel("Count")

plt.show()

df['TotalIncome']= df['ApplicantIncome'] + df['CoapplicantIncome']
df['TotalIncome_log']= np.log(df['TotalIncome'])
df['TotalIncome_log'].hist(bins=20)

df['LoanAmount_log']= np.log(df['LoanAmount'])

#filling null values
df['Gender'].fillna(df['Gender'].mode()[0], inplace=True)
df['Married'].fillna(df['Married'].mode()[0], inplace=True)
df['Dependents'].fillna(df['Dependents'].mode()[0], inplace=True)
df['Self_Employed'].fillna(df['Self_Employed'].mode()[0], inplace=True)
#filling loan amount with the mean
df.LoanAmount= df.LoanAmount.fillna(df.LoanAmount.mean())
df.LoanAmount_log= df.LoanAmount_log.fillna(df.LoanAmount_log.mean())

df['Loan_Amount_Term'].fillna(df['Loan_Amount_Term'].mode()[0], inplace=True)
df['Credit_History'].fillna(df['Credit_History'].mode()[0], inplace=True)

df.isnull().sum()

#selecting some columns for training
x=df.iloc[:,np.r_[1:5,9:11,13:15]].values
y=df.iloc[:,12].values
x

y

print("percentage of missing gender is %2f%%" %((df['Gender'].isnull().sum()/df.shape[0] * 100)))

df.shape[0]

print("number of people who take loan as group by gender: ")
print(df['Gender'].value_counts())
sns.countplot(x='Gender', data=df, palette='Set1')

print("number of people who take loan as group by marital status: ")
print(df['Married'].value_counts())
sns.countplot(x='Married', data=df, palette='Set1')

print("number of people who take loan as group by self employed: ")
print(df['Self_Employed'].value_counts())
sns.countplot(x='Self_Employed', data=df, palette='Set1')

print("number of people who take loan as group by dependents: ")
print(df['Dependents'].value_counts())
sns.countplot(x='Dependents', data=df, palette='Set1')

print("number of people who take loan as group by loan amount: ")
print(df['LoanAmount'].value_counts())
sns.countplot(x='LoanAmount', data=df, palette='Set1')

# Define loan amount ranges
bins = [0, 100, 200, 300, 400, 500, 600, 700, float("inf")]
labels = ['0-100', '101-200', '201-300', '301-400', '401-500', '501-600', '601-700', '700+']

# Create a new column in your DataFrame to represent the loan amount ranges
df['LoanAmountRange'] = pd.cut(df['LoanAmount'], bins=bins, labels=labels, include_lowest=True)

# Group the data by 'LoanAmountRange' and calculate the mean loan amount in each range
loan_amount_summary = df.groupby('LoanAmountRange')['LoanAmount'].mean().reset_index()

# Rename columns for clarity
loan_amount_summary.columns = ['Loan Amount Range', 'Average Loan Amount']

# Display the table
print(loan_amount_summary)

print("number of people who take loan as group by loan amount: ")
print(df['Credit_History'].value_counts())
sns.countplot(x='Credit_History', data=df, palette='Set1')

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test= train_test_split(x,y, test_size=0.2, random_state=0)

from sklearn.preprocessing import LabelEncoder
LabelEncoder_x= LabelEncoder()

for i in range(0,5):
    X_train[:, i]= LabelEncoder_x.fit_transform(X_train[:,i])
    X_train[:,7]=LabelEncoder_x.fit_transform(X_train[:,7])
X_train

LabelEncoder_y= LabelEncoder()
y_train= LabelEncoder_y.fit_transform(y_train)


y_train

for i in range(0,5):
    X_test[:,i]= LabelEncoder_x.fit_transform(X_test[:,i])
    X_test[:,7]= LabelEncoder_x.fit_transform(X_test[:,7])

X_test

LabelEncoder_y= LabelEncoder()
y_test= LabelEncoder_y.fit_transform(y_test)


y_test

from sklearn.preprocessing import StandardScaler
scaler= StandardScaler()
X_train= scaler.fit_transform(X_train)
X_test= scaler.fit_transform(X_test)

from sklearn.ensemble import RandomForestClassifier

rf_clf= RandomForestClassifier()
rf_clf.fit(X_train, y_train)

#checking which columns are best fit for prediction
from sklearn import metrics
y_pred= rf_clf.predict(X_test)
print("accuracy of random forest classifier is: ", metrics.accuracy_score(y_pred, y_test))

y_pred
